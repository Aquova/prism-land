using System.Collections; using System.Collections.Generic; using UnityEngine;  public class CameraControllerMouse : MonoBehaviour {  	private GameObject player; 	private Vector3 offset; 	public float boardTiltMax = 0f; // Maximum angle to tilt the camera to fake the level tilting 	private Vector3 desiredPosition; 	private GameObject desiredPositionObject;  	private float rotationDamping = 10f; 	private float movementDamping = 150f;   	public bool lockCursor = true; 	private bool m_cursorIsLocked = true;  	//options for different inputs 	[SerializeField] private bool useKeysQE = true; 	private float turnAngle = 0.0f; 	[SerializeField] private float turnSpeed = 300f;   	[SerializeField] private bool useMouseX = true; 	[SerializeField] private float turnSpeedMouseX = 300f;   	[SerializeField] private bool useMouseY = true; 	private float turnMouseY = 0.0f; 	[SerializeField] private float turnSpeedMouseY = 300f; 	[SerializeField] private float m_TiltMax = 40f; 	[SerializeField] private float m_TiltMin = 35f;   	// Use this for initialization 	void Start() 	{ 		desiredPosition = transform.position; 		desiredPositionObject = new GameObject("cameraFollow"); 		DontDestroyOnLoad(desiredPositionObject); 		desiredPositionObject.transform.position = transform.position;    		// fine the player object 		player = GameObject.Find("Player");  		if (player == null) 		{  			//Debug.LogError("Could not find object \ "Player\ " ! Aborting GameCamera load."); 			DestroyImmediate(gameObject); 		} 		offset = transform.position - player.transform.position;  	}  	void Update() 	{ 		UpdateCursorLock (); 		if (useKeysQE) { 			turnAngle += Input.GetAxis ("Turn") * turnSpeed * Time.deltaTime; 		} 		if (useMouseX) { 			turnAngle += Input.GetAxis ("Mouse X") * turnSpeedMouseX * Time.deltaTime; 		} 		if (useMouseY) { 			turnMouseY -= Input.GetAxis ("Mouse Y") * turnSpeedMouseY * Time.deltaTime; 		} 	}  	public static float ClampAngle(float angle, float min, float max) 	{ 		if (angle < -360F) 			angle += 360F; 		if (angle > 360F) 			angle -= 360F; 		return Mathf.Clamp(angle, min, max); 	}  	void LateUpdate() 	{ 		// find the ZX direction from the player to the camera 		var heading = transform.position - player.transform.position; 		heading.y = 0f; 		var distance = heading.magnitude; 		var direction = heading / distance;  		// Find the right vector for the diretion 		var rotationVectorRight = Vector3.Cross(direction, Vector3.up); 		// Move the camera 		desiredPositionObject.transform.position = player.transform.position + offset;   		// Rotate around the players Y axis by the turn value 		desiredPositionObject.transform.RotateAround (player.transform.position, Vector3.up, turnAngle); 		if (useMouseY) { 			//Debug.Log (turnMouseY); 			turnMouseY = ClampAngle(turnMouseY, -m_TiltMin, m_TiltMax); 			desiredPositionObject.transform.RotateAround (player.transform.position, Vector3.right, turnMouseY);  		}  		// Deal with forward/backward board rotation 		desiredPositionObject.transform.RotateAround(player.transform.position, rotationVectorRight, -Input.GetAxisRaw("Vertical") * boardTiltMax);  		// Ensure we're looking at the player before the roll rotation is applied 		desiredPositionObject.transform.LookAt(player.transform.position);  		// Apply the roll rotation 		desiredPositionObject.transform.RotateAround(desiredPositionObject.transform.position, direction, -Input.GetAxisRaw("Horizontal") * boardTiltMax);  		// Lerp the cameras position to match the target object 		transform.position = Vector3.Slerp(transform.position, desiredPositionObject.transform.position, Time.deltaTime * movementDamping);  		// Lerp the cameras rotation to match the target object 		transform.rotation = Quaternion.Lerp(transform.rotation, 			desiredPositionObject.transform.rotation, 			Time.deltaTime * rotationDamping);  		// Re-center the camera on the object to account for new roll rotation 		CenterCameraOnTarget();  	}  	private void CenterCameraOnTarget() 	{ 		Plane plane = new Plane(transform.forward, player.transform.position); 		Ray ray = GetComponentInChildren<Camera>().ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0.0f)); 		float distance; 		plane.Raycast(ray, out distance);  		var point = ray.GetPoint(distance); 		var offset = player.transform.position - point; 		transform.position += offset; 	}  	public void UpdateCursorLock() 	{ 		if (lockCursor) 			InternalLockUpdate(); 	}  	private void InternalLockUpdate() 	{ 		if(Input.GetKeyUp(KeyCode.Escape)) 		{ 			m_cursorIsLocked = false; 		} 		else if(Input.GetMouseButtonUp(0)) 		{ 			m_cursorIsLocked = true; 		}  		if (m_cursorIsLocked) 		{ 			Cursor.lockState = CursorLockMode.Locked; 			Cursor.visible = false; 		} 		else if (!m_cursorIsLocked) 		{ 			Cursor.lockState = CursorLockMode.None; 			Cursor.visible = true; 		} 	} } 